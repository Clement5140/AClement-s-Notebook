<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="meta-learning/index.html"><strong aria-hidden="true">1.</strong> Meta-Learning</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="meta-learning/MAML.html"><strong aria-hidden="true">1.1.</strong> Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks</a></li><li class="chapter-item expanded "><a href="meta-learning/MAML++.html"><strong aria-hidden="true">1.2.</strong> HOW TO TRAIN YOUR MAML</a></li><li class="chapter-item expanded "><a href="meta-learning/ANIL.html"><strong aria-hidden="true">1.3.</strong> RAPID LEARNING OR FEATURE REUSE? TOWARDS UNDERSTANDING THE EFFECTIVENESS OF MAML</a></li><li class="chapter-item expanded "><a href="meta-learning/FO-MAML.html"><strong aria-hidden="true">1.4.</strong> On First-Order Meta-Learning Algorithms</a></li><li class="chapter-item expanded "><a href="meta-learning/HF-MAML.html"><strong aria-hidden="true">1.5.</strong> On the Convergence Theory of Gradient-Based Model-Agnostic Meta-Learning Algorithms</a></li><li class="chapter-item expanded "><a href="meta-learning/iMAML.html"><strong aria-hidden="true">1.6.</strong> Meta-Learning with Implicit Gradients</a></li></ol></li><li class="chapter-item expanded "><a href="autonomous-systems/index.html"><strong aria-hidden="true">2.</strong> Autonomous Systems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="autonomous-systems/planning&decision-making.html"><strong aria-hidden="true">2.1.</strong> [review]Planning and Decision-Making for Autonomous Vehicles</a></li><li class="chapter-item expanded "><a href="autonomous-systems/motion-planning-review.html"><strong aria-hidden="true">2.2.</strong> [review]A Review of Mobile Robot Motion Planning Methods</a></li><li class="chapter-item expanded "><a href="autonomous-systems/RL/index.html"><strong aria-hidden="true">2.3.</strong> RL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="autonomous-systems/RL/A3C.html"><strong aria-hidden="true">2.3.1.</strong> Asynchronous Methods for Deep Reinforcement Learning (A3C)</a></li><li class="chapter-item expanded "><a href="autonomous-systems/RL/LRF/curiosity-driven.html"><strong aria-hidden="true">2.3.2.</strong> Curiosity-driven Exploration by Self-supervised Prediction</a></li><li class="chapter-item expanded "><a href="autonomous-systems/RL/LRF/end-to-end nav strategy with DRL.html"><strong aria-hidden="true">2.3.3.</strong> End-to-End Navigation Strategy With Deep Reinforcement Learning for Mobile Robots</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="meta-learning"><a class="header" href="#meta-learning">Meta-Learning</a></h1>
<p>元学习相关论文。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="model-agnostic-meta-learning-for-fast-adaptation-of-deep-networks"><a class="header" href="#model-agnostic-meta-learning-for-fast-adaptation-of-deep-networks">Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks</a></h1>
<p>作者将元学习问题形式化后提出了一个模型无关的元学习算法MAML。</p>
<h2 id="问题设置"><a class="header" href="#问题设置">问题设置</a></h2>
<p>用 \(f\) 表示一个机器学习中模型，可以将输入分布中的一个观测 \(x\) 映射到输出 \(a\) 。</p>
<p>元学习中，每个任务表示为 \(T={L(x_1,a_1,..,x_H,a_H),q(x_1),q(x_{t+1}|x_t,a_t),H}\)，其中 \(L(x_1,a_1,..,x_H,a_H)\rightarrow \mathbb{R}\) 为损失函数，\(q(x_1)\) 表示初始观测 \(x_1\) 的分布，而 \(q(x_{t+1}|x_t,a_t)\) 表示转移的分布，用于适应不同模型。对于i.i.d的监督学习，\(H=1\)。</p>
<p>考虑学习任务的分布 \(p(T)\) ，元学习要学习的就是该分布。在K样本(K-shot)的学习中，元学习的训练使用分布 \(p(T)\) 中的任务 \(T_i\)，然后用该任务中 \(q_i\) 的K个样本和 \(L_{T_i}\) 进行训练，并用 \(T_i\) 中新的样本进行测试，得到的测试误差用作整个元学习的训练误差。最终使用分布 \(p(T)\) 采样的新任务来测试元学习模型。</p>
<h2 id="maml算法"><a class="header" href="#maml算法">MAML算法</a></h2>
<p>算法目标是寻找敏感的模型参数，使得其面对分布 \(p(T)\) 中新的任务时，对参数较小的修改就可以使新任务的模型产生很大的提升。算法对模型没有假设，只假设其可以用一组参数 \(\theta\) 表示，并且其可以使用基于梯度的学习技术来更新。</p>
<p>元学习算法中，每个任务中的模型用 \(f_{\theta}\) 表示，并对于一个新的任务 \(T_i\) ，模型适应后参数记为 \(\theta_i'\) ，其可以通过一次或多次梯度下降得到，每次梯度下降可以表示为：</p>
<p>$$
\theta_i' = \theta - \alpha \nabla_\theta L_{T_i}(f_\theta)
$$</p>
<p>其中 \(\alpha\) 为超参数或可以被元学习。</p>
<p>元学习的目标是将模型 \(f_{\theta_i'}\) 的效果最优化：</p>
<p>$$
\min_{\theta}\sum_{T_i \sim p(T)}L_{T_i}(f_{\theta_i'})=\sum_{T_i \sim p(T)}L_{T_i}(f_{\theta - \alpha \nabla_\theta L_{T_i}(f_\theta)})
$$</p>
<p>学习目标最终体现在得到的模型参数\(\theta\)中：</p>
<p>$$
\theta \leftarrow \theta - \beta \nabla_\theta \sum_{T_i \sim p(T)}L_{T_i}(f_{\theta_i'})
$$</p>
<p>MAML对新的任务，使用该参数\(\theta\)经过较少的新任务中的样本训练后，就可以得到很好的效果。</p>
<h3 id="监督学习回归和分类"><a class="header" href="#监督学习回归和分类">监督学习(回归和分类)</a></h3>
<p>设置\(H=1\)。</p>
<p>对于回归类的任务，使用MSE：</p>
<p>$$
L_{T_i}(f_{\phi})=\sum_{x^{(j)},y^{(j)} \sim T_i}||f_\phi(x^{(j)})-y^{(j)}||^2_2
$$</p>
<p>其中，\(x^{(j)},y^{(j)}\)为任务\(T_i\)的样本对，K样本的回归任务中，每个任务取K个进行训练。</p>
<p>对于离散的分类任务，使用cross entropy：</p>
<p>$$
L_{T_i}(f_{\phi})=\sum_{x^{(j)},y^{(j)} \sim T_i}y^{(j)}log f_\phi(x^{(j)})+(1-y^{(j)})log (1-f_\phi(x^{(j)}))
$$</p>
<p>K样本N分类任务的训练中，每一类需要K个样本，每个任务需要NK个数据。</p>
<h3 id="强化学习"><a class="header" href="#强化学习">强化学习</a></h3>
<p>每个强化学习任务包含初始状态分布\(q_i(x_1)\) ，一个转移分布 \(q_i(x_{t+1}|x_t,a_t)\) 和由(负的)奖励函数\(R\)定义的损失函数\(L_{T_i}\)。整个任务是一个马尔可夫决策过程，长度为H。学习的模型\(f_\theta\)可以将每一步\(t\in{1,...,H}\)的\(x_t\)状态映射到一个动作\(a_t\)上。形式为：</p>
<p>$$
L_{T_i}(f_\phi)=-\mathbb{E_{x_t,a_t \sim f_\phi,q_{T_i}}}[\sum_{t=1}^{H}R_i(x_t,a_t)]
$$</p>
<h2 id="测试结果"><a class="header" href="#测试结果">测试结果</a></h2>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="how-to-train-your-maml"><a class="header" href="#how-to-train-your-maml">HOW TO TRAIN YOUR MAML</a></h1>
<h2 id="maml的问题"><a class="header" href="#maml的问题">MAML的问题</a></h2>
<ul>
<li>训练不稳定性
<blockquote>
<p>训练时很不稳定，依赖于神经网络的架构和外层超参数的设定。
可能导致梯度爆炸或梯度消失。</p>
</blockquote>
</li>
<li>二阶导的成本
<blockquote>
<p>梯度更新需要计算二阶导，非常昂贵，MAML中提出使用一阶近似来加速这个过程，但这样做会对最终泛化误差产生负面的影响。
在不牺牲泛化性能的情况下减少计算时间的方法还没有被提出。</p>
</blockquote>
</li>
<li>批处理归一化(Batch Normalization)统计量累积的缺失
<blockquote>
<p>在原MAML论文中实验里批处理归一化使用方式是有问题的，其没有累积得到的统计量，而是直接将当前统计量用于批处理归一化，这样学习到的偏差需要适应不同的均值和标准偏差，而如果使用的是累积的统计量，那么最终会收敛到某个全局的均值和标准偏差，并且这样做收敛更快、更稳定、泛化性能更好。</p>
</blockquote>
</li>
<li>共享(跨步)批处理归一化偏差
<blockquote>
<p>另一个问题是其批处理归一化偏差并不是在inner-loop中更新的，而在整个base-model迭代中使用了同样的bias，这含蓄地假设了所有的base-model在inner-loop中更新时都一样，即其特征有同样的分布，但这个假设是错误的。在每个inner-loop中，会有新的base-model产生，并且其和之前的模型有足够的不同，从bias的估计上应该被认为是一个新的模型。</p>
</blockquote>
</li>
<li>共享内循环(跨步和跨参数)学习率
<blockquote>
<p>还有个同时影响泛化性能和收敛速度(用训练迭代次数表示)的问题是所有参数和更新都使用同一个共享的学习率。这样需要一个固定的学习率，需要进行多次超参数调整，可能会非常昂贵。
Learning to learn quickly for few shot learning. arXiv preprint arXiv:1707.09835, 2017.的作者提出可以对网络每个参数的学习率进行学习，可以解决上述问题，但也有自己的问题，这样会增加计算和内存空间的成本。</p>
</blockquote>
</li>
<li>固定的外循环学习率
<blockquote>
<p>MAML中作者使用固定学习率的Adam来训练元优化器，使用阶跃函数或余弦函数对学习速率进行退火已被证明是在多种设置下实现先进的泛化性能的关键，因此证明了使用静态学习率有可能降低了MAML的泛化性能和优化速度，并且固定的学习率也意味着须花费更多的时间调整。</p>
</blockquote>
</li>
</ul>
<h2 id="maml"><a class="header" href="#maml">MAML++</a></h2>
<p>一个一个解决上述问题。</p>
<ul>
<li>梯度不稳定性 -&gt; 多步损失优化(Multi-Step Loss Optimization, MSL)
<blockquote>
<p>在每个base-model的inner-loop中，对support-set中的每一步都对目标进行更新：
$$
\theta = \theta - \beta \nabla_\theta \sum_{b=1}^B \sum_{i=0}^N v_i L_{T_b}(f_{\theta_i^b})
$$
b表示任务，i表示每个任务中第i步，\(v_i\)表示第i步后的权重。
还需要对每步损失的权重进行退火，一开始所有损失贡献相同，但随着训练迭代，我们减少靠前步骤的权重，缓慢增加靠后步骤的权重，这保证随着训练的进行，优化器会更重视最终的步骤从而达到最低可能的损失。</p>
</blockquote>
</li>
<li>二阶导成本 -&gt; 导数退火(Derivative-Order Annealing, DA)
<blockquote>
<p>原MAML算法中需要计算二阶导，其作者提出使用一阶近似来计算，但他是在整个训练过程中都使用一阶近似。MAML++提出，可以在前50个epochs中使用一阶近似，而之后都使用二阶导计算，这样经过经验可以得到前50个epochs可以被极大地加速，并且后面使用二阶导计算可以得到很强的泛化性能。
并且还可以观察到，这样做可以避免梯度爆炸和梯度消失，而全部直接使用二阶导会更加不稳定。说明DA比单独使用标准MAML算法更加稳定，使用一阶近似进行训练相当于标准MAML的一种预训练，让后期MAML对模型的训练更好之外，可以避免标准MAML算法出现梯度衰减、梯度爆炸现象。</p>
</blockquote>
</li>
<li>批处理归一化统计量累积的缺失 -&gt; 每步批处理归一化处理统计量(Per-Step Batch Normalization Running Statistics, BNRS)
<blockquote>
<p>MAML++提出在每步中收集统计量，需要在网络的每一批归一化层都实例化N组running均值和标准偏差，然后随着优化的每一步分别更新这些统计量。</p>
</blockquote>
</li>
<li>共享(跨步)批处理归一化偏差 -&gt; 每步的批处理归一化权重和偏差(Per-Step Batch Normalization Weights and Biases, BNWB)
<blockquote>
<p>MAML++提出在inner-loop更新过程中每步都学习一组偏差。这样做意味着Batch Normalization将学习特定于在每个集合处看到的特征分布的偏差，这将提高收敛速度，稳定性和泛化性能。</p>
</blockquote>
</li>
<li>共享内循环(跨步和跨参数)学习率 -&gt; 每层每步的学习率和梯度方向的学习(Learning Per-Layer Per-Step Learning Rates and Gradient Directions, LSLR)
<blockquote>
<p>之前提到，Learning to learn quickly for few shot learning. arXiv preprint arXiv:1707.09835, 2017.的作者提出可以对网络每个参数的学习率进行学习，可以解决上述问题，但也有自己的问题，这样会增加计算和内存空间的成本。 MAML++提出对网络中每一层学习一个学习率和一个搜索方向。</p>
</blockquote>
</li>
<li>固定的外循环学习率 -&gt; 元优化器学习率的余弦退火(Cosine Annealing of Meta-Optimizer Learning Rate, CA)
<blockquote>
<p>原MAML模型采用固定的外循环学习率，MAML++提出对元学习优化器(外循环)学习率使用余弦退火。</p>
</blockquote>
</li>
</ul>
<h2 id="实验结果"><a class="header" href="#实验结果">实验结果</a></h2>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="rapid-learning-or-feature-reuse-towards-understanding-the-effectiveness-of-maml"><a class="header" href="#rapid-learning-or-feature-reuse-towards-understanding-the-effectiveness-of-maml">RAPID LEARNING OR FEATURE REUSE? TOWARDS UNDERSTANDING THE EFFECTIVENESS OF MAML</a></h1>
<p>文章目的是探讨MAML有效的原因是可以快速学习还是特征重复利用，前者模型在遇到新的任务时会进行大量、有效的修改，而后者是说模型在训练之后已经包含了相关任务高质量的特征。</p>
<p>文章直接给出结论：MAML有效的原因是特征重复利用（feature reuse），通过layer freezing experiments和分析MAML模型latent representations来证明结论，并在结论上提出MAML的简化版本ANIL。</p>
<h2 id="freezing-layer-representations"><a class="header" href="#freezing-layer-representations">FREEZING LAYER REPRESENTATIONS</a></h2>
<p>作者提出模型的网络需要分为两个部分：head和body，head指网络最后一层，body指前面其余的层。</p>
<p>在每个few-shot任务中，网络最后一层也就是head需要将神经元和类别对应起来，所以不同的任务inner-loop训练后head层会有较大不同，所以只需要主要关注body层的表现。</p>
<p>layer freezing experiments指在测试时禁止网络的body层的一个连续子集的参数更新，来对比这些结果，比如：网络一共四层，记为1、2、3、4，最后还有一个head层，实验会进行五次，第一次不禁止更新，第二次禁止第1层更新，第三次禁止第1、2层更新，以此类推。</p>
<p>结果显示对参数禁止更新几乎不影响模型的准确率，即使禁止body中的所有层更新参数，模型的表现也没有怎么下降。</p>
<h2 id="representational-similarity-experiments"><a class="header" href="#representational-similarity-experiments">REPRESENTATIONAL SIMILARITY EXPERIMENTS</a></h2>
<p>这个实验分析神经网络在每个任务的inner loop适应后latent representations有多少改变。</p>
<p>作者使用了CCA相似度和CKA相似度来对网络的每一层在inner loop前后的不同进行测试，CCA提供了一种方法可以比较神经网络中的两个层的表示的相似度(从0到1，分数越接近1越相似)，结果发现网络body的所有层相似度都大于0.9，只有head层小于0.5，也符合之前的想法。</p>
<h2 id="anilalmost-no-inner-loop算法"><a class="header" href="#anilalmost-no-inner-loop算法">ANIL(Almost No Inner Loop)算法</a></h2>
<p>在ANIL算法中，作者移除了训练和测试时inner loop对网络body层的更新，只保留对head层的更新，其余和MAML算法一样。</p>
<p>由于ANIL算法几乎没有inner loop，其速度有显著提升，并且：</p>
<ul>
<li>模型的表现能够达到MAML的水平，不管是few-shot图像分类还是强化学习场景下。</li>
<li>ANIL和MAML训练时的loss和acc曲线几乎一致，使用CCA和CKA相似度发现MAML-ANIL表示和MAML-MAML表示以及ANIL-ANIL表示有同样的平均相似度得分，说明两个算法学习的特征是类似的，训练时有没有inner loop更新不会改变学习到的特征种类。</li>
</ul>
<h2 id="网络head和body的贡献"><a class="header" href="#网络head和body的贡献">网络head和body的贡献</a></h2>
<p>好的特征已经被学习到的情况下，测试时网络的head有多重要？</p>
<h3 id="nilno-inner-loop算法"><a class="header" href="#nilno-inner-loop算法">NIL(No Inner Loop)算法</a></h3>
<p>在训练之后，好的特征已经被学习到了，探讨此时(测试时)head的重要性。</p>
<p>NIL算法：</p>
<ul>
<li>1.使用ANIL/MAML算法训练一个few-shot模型，作者使用了ANIL。</li>
<li>2.测试时，移除训练模型的head，对于每个任务，先将k个有标签的数据(支撑集support set)传入网络的body，得到他们倒数第二层的表示，然后对于一个测试数据，计算他倒数第二层的表示和支撑集的表示的余弦相似度(cosine similarities)，使用这些相似性来加权支撑集的标签。</li>
</ul>
<p>NIL算法得到的模型性能和ANIL和MAML类似，说明MAML/ANIL训练得到的网络body学习到的特征是最重要的。</p>
<h3 id="网络body的训练方式"><a class="header" href="#网络body的训练方式">网络body的训练方式</a></h3>
<p>NIL又引出一个问题：训练时head和task alignment的重要性。</p>
<p>训练时使用NIL方法，即没有head，得到的模型表现会降低很多，说明训练时head是很重要的。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="on-first-order-meta-learning-algorithms"><a class="header" href="#on-first-order-meta-learning-algorithms">On First-Order Meta-Learning Algorithms</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="on-the-convergence-theory-of-gradient-based-model-agnostic-meta-learning-algorithms"><a class="header" href="#on-the-convergence-theory-of-gradient-based-model-agnostic-meta-learning-algorithms">On the Convergence Theory of Gradient-Based Model-Agnostic Meta-Learning Algorithms</a></h1>
<p>文章研究了MAML和FO-MAML的收敛理论，根据梯度范数分析了它们对于非凸损失函数的计算复杂度和能够达到的准确率级别(level)。</p>
<p>作者提出MAML对于任意的\(\epsilon\)，可以在\(O(1/\epsilon^2)\)次迭代内找到一个\(\epsilon\)-一阶导不动点，每次迭代复杂度为\(O(d^2)\)，\(d\)为问题维数，而FO-MAML将每次迭代的复杂度降低为了\(O(d)\)，但不能保证达到想要的准确率级别。</p>
<p>最后作者提出Hessian-free MAML(HF-MAML)算法，既能保有MAML的所有理论保证，又能降低每次迭代的复杂度为\(O(d)\)。</p>
<h2 id="maml算法和fo-maml算法"><a class="header" href="#maml算法和fo-maml算法">MAML算法和FO-MAML算法</a></h2>
<p>作者用自己的符号表示了两个算法：</p>
<p><img src="meta-learning/assets/HF-MAML-1.png" alt="1" /></p>
<p><img src="meta-learning/assets/HF-MAML-2.png" alt="2" /></p>
<p>其中MAML算法需要求损失函数的二阶导Hessian矩阵，而FO-MAML将其近似掉了，作者这里设置计算二阶导的数据集\(D_h^i\)和计算一阶导的数据集\(D_o^i\)相互独立，为了使用更小的\(D_h^i\)来减少计算量。</p>
<h2 id="hessian-free-maml"><a class="header" href="#hessian-free-maml">Hessian-free MAML</a></h2>
<p>对于任意函数\(\phi\)，其Hessian矩阵和任意向量\(v\)的乘积可以近似为</p>
<p>$$
\nabla^2\phi(w)v \approx \Bigg[\frac{\nabla\phi(w + \delta v) - \nabla\phi(w - \delta v)}{2\delta}\Bigg]
$$</p>
<p>其误差不超过\(\rho\delta||v||^2\)，\(\rho\)为\(\phi\)的Hessian矩阵的利普希茨连续常数。</p>
<p>将其带入之前MAML的更新中得到</p>
<p>$$
d_k^i := \frac{\tilde{\nabla}f_i\Big(w_k+\delta_k^i\tilde{\nabla}f_i(w_k-\alpha \tilde{\nabla}f_i(w_k,D_{in}^i),D_o^i),D_h^i\Big)-f_i\Big(w_k-\delta_k^i\tilde{\nabla}f_i(w_k-\alpha \tilde{\nabla}f_i(w_k,D_{in}^i),D_o^i),D_h^i\Big)}{2\delta_k^i}
$$</p>
<p>$$
w_{k+1} = w_k - \beta_k \frac{1}{B} \sum_{i \in B_k} \Big[\tilde{\nabla}f_i(w_k-\alpha \tilde{\nabla}f_i(w_k, D_in^i), D_o^i) - \alpha d_k^i\Big]
$$</p>
<p>HF-MAML的算法如下：</p>
<p><img src="meta-learning/assets/HF-MAML-3.png" alt="3" /></p>
<h2 id="理论分析"><a class="header" href="#理论分析">理论分析</a></h2>
<p>设\(T = {T_i}_{i \in I} \)表示所有任务的集合，\(p\)表示\(T\)的概率分布，\(T_i\)以\(p_i := p(T_i)\)的概率被抽样，\(T_i\)的损失函数用\(f_i(w):\mathbb{R}^d \rightarrow \mathbb{R}\)表示，定义期望</p>
<p>$$
f(w) := \mathbb{E}_{i \sim p} [f_i(w)]
$$</p>
<p>元学习优化问题：</p>
<p>$$
\min_{w \in \mathbb{R}^d} F(w) := \mathbb{E} _ {i \sim p} [F_i(w)] := \mathbb{E} _ {i \sim p} [f_i(w - \alpha \nabla f_i(w))]
$$</p>
<p>假设\(F\)为一般的非凸但光滑的函数。</p>
<p><strong>定义1</strong>：向量\(w_\epsilon \in \mathbb{R}^d\)被称为上述优化问题的\(\epsilon\)-近似一阶不动点(first order stationary point, FOSP)，如果其满足：</p>
<p>$$
\mathbb{E} [||\nabla F(w_\epsilon)||] \leq \epsilon
$$</p>
<p>定义说明一个点\(w_\epsilon\)是一个\(\epsilon\)-FOSP，如果它对全局损失函数\(F\)的梯度模长(gradient norm)的期望小于\(\epsilon\)。</p>
<p>本节的目的是对于MAML、FO-MAML和HF-MAML寻找两个问题的答案：</p>
<ul>
<li>对于任意的\(\epsilon&gt;0\)，可以找到一个\(\epsilon\)-FOSP吗？</li>
<li>若可以，需要多少次迭代才能到达该不动点？</li>
</ul>
<p><strong>假设1</strong>：\(F\)有下界，即\(\min_{w \in \mathbb{R}^d} F(w) &gt; -\infty\)。</p>
<p><strong>假设2</strong>：对于任意\(i \in I\)，\(f_i\)二次连续可微且\(L_i\)-光滑，即对于任意\(w,u \in \mathbb{R}^d\)，有</p>
<p>$$
||\nabla f_i(w) - \nabla f_i (u)|| \leq L_i ||w - u||
$$</p>
<p>在二次连续可微的假设下，再假设一阶导\(L_i\)-光滑可以推出：</p>
<p>$$
-L_i I_d \preceq \nabla^2 f_i(w) \preceq L_i I_d, \forall w \in \mathbb{R}^d \
-\frac{L_i}{2} ||w - u||^2 \leq f_i(w) - f_i(u) - \nabla f_i(u)^\top (w-u) \leq \frac{L_i}{2}||w-u||^2, \forall w, u \in \mathbb{R}^d
$$</p>
<p>为了简单，此后使用\(L := \max_i L_i\)，可以被看作所有\(i \in I\)的\(\nabla f_i\)利普希茨连续常数。</p>
<p>在MAML的参数更新中出现了\(f_i\)的二阶导，所以需要对目标函数的Hessian矩阵施加一个正则性条件：</p>
<p><strong>假设3</strong>：</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="meta-learning-with-implicit-gradients"><a class="header" href="#meta-learning-with-implicit-gradients">Meta-Learning with Implicit Gradients</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="autonomous-systems"><a class="header" href="#autonomous-systems">Autonomous Systems</a></h1>
<p>自动驾驶相关论文。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="planning-and-decision-making-for-autonomous-vehicles"><a class="header" href="#planning-and-decision-making-for-autonomous-vehicles">Planning and Decision-Making for Autonomous Vehicles</a></h1>
<h2 id="1介绍"><a class="header" href="#1介绍">1.介绍</a></h2>
<p>主要介绍自动驾驶规划和决策的多个方面，大致分为三种不同的方法：<br />
sequential planning(section 2)，behavior-aware planning(section 4)和end-to-end planning(section 3)。<br />
section 5讲各种方法如何验证和综合，section 6讲自动驾驶车辆车队(fleet)的管理方法。</p>
<h2 id="2motion-planning-and-control"><a class="header" href="#2motion-planning-and-control">2.MOTION PLANNING AND CONTROL</a></h2>
<p>主要是一些车辆控制和运动规划的传统方法。<br />
先讲parallel autonomy，再讲autonomous vehicles，最后列出决策和规划目前的一些挑战。</p>
<h3 id="车辆动力学和控制"><a class="header" href="#车辆动力学和控制">车辆动力学和控制</a></h3>
<p>低速情况下，有运动学模型可以控制车辆。而高速情况下，需要使用车辆的完整动力学模型，包括轮胎的力等。<br />
一些模型：Nonlinear control (18), model predictive control (19), feedback–feedforward control (20)</p>
<p>这些模型依赖于需要识别的车辆模型，有基于优化的技术和基于学习的技术。</p>
<h3 id="parallel-autonomy"><a class="header" href="#parallel-autonomy">parallel autonomy</a></h3>
<p>有三种collaborative autonomy的方式：series autonomy，interleaved autonomy，parallel autonomy。<br />
parallel autonomy指自动驾驶系统处于后台运行来保证安全，而由人来操作车辆，当人被转移注意力或无法处理当前情况时，该系统会提供安全性。</p>
<p>比较直观的做法是将人的输入和安全系统的输出直接线性组合起来，Anderson et al. (23)。</p>
<p>另一种做法是将人的输入以最低影响的方式合并到优化框架中。Alonso-Mora et al. (25)，Shia et al. (26) ，Erlien et al. (27)。</p>
<h3 id="运动规划"><a class="header" href="#运动规划">运动规划</a></h3>
<p>大多数计算安全路径的传统方法都是基于以下三种思路：</p>
<ul>
<li>支持碰撞检测的输入空间离散化(input space discretization with collision checking)
<ul>
<li>lattice planners (e.g., 31, 32)</li>
<li>road-aligned primitives (e.g., 33)</li>
</ul>
</li>
<li>随机规划(randomized planning)
<ul>
<li>rapidly exploring random trees (RRT) (e.g., 34, 35)</li>
</ul>
</li>
<li>约束优化和滚动时域控制(constrained optimization and receding-horizon control(e.g., 19, 36))
<ul>
<li>Schwarting et al. (28)</li>
</ul>
</li>
</ul>
<h2 id="3integrated-perception-and-planning"><a class="header" href="#3integrated-perception-and-planning">3.INTEGRATED PERCEPTION AND PLANNING</a></h2>
<p>主要介绍感知的前沿技术，描述综合感知和规划的端到端方法(end-to-end methods)，直接从感知信息生成车辆的控制输入，非常依赖机器学习。</p>
<h3 id="从经典感知到基于神经网络的感知系统的目前的挑战"><a class="header" href="#从经典感知到基于神经网络的感知系统的目前的挑战">从经典感知到基于神经网络的感知系统的目前的挑战</a></h3>
<p>一些benchmarking数据集：KITTI (42), ISPRS (International Society for Photogrammetry and Remote Sensing), MOT (Multiple Object Tracking), and Cityscapes (43)。</p>
<p>经典感知系统从原始感知数据中以人工设计的特征形式提取信息。最著名的一些例子：SIFT (Scale-Invariant Feature Transform) (44, 45), BRISK (Binary Robust Invariant Scalable Keypoints) (46), SURF (Speeded Up Robust Features) (47, 48), and ORB (Oriented FAST and Rotated BRIEF) (49, 50)。<br />
基于纯视觉的迅速、轻量级的方法已经成熟：such asORB-SLAM2 (50), SVO(SemidirectVisualOdometry) 2.0 (52), and LSD-SLAM (Large-Scale DirectMonocular SLAM) (53)。</p>
<p>物体检测一般有两种方式：碰撞盒检测和语义分割。</p>
<ul>
<li>碰撞盒检测
<ul>
<li>the ImageNet Large Scale Visual Recognition Challenge (55)</li>
<li>real-time-capable systems such as Faster R-CNN (Faster Regional Convolutional Neural Network) (56)</li>
</ul>
</li>
<li>语义分割
<ul>
<li>ResNet38 (57) and PSPNet (Pyramid Scene Parsing Network) (58)
<ul>
<li>achieve more than 80% mIoU (mean intersection over union) in the Cityscapes data set (43)</li>
<li>but take multiple seconds to propagate on high-resolution images</li>
</ul>
</li>
<li>ENet (Efficient Neural Network) (59)
<ul>
<li>achieved a 13-ms runtime on 1,024×2,048–pixel images with 58% mIoU on theCityscapes data set (43)</li>
</ul>
</li>
<li>ICNet (ImageCascadeNetwork) (60)
<ul>
<li>achieved 70% mIoU at 33 ms</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>真实世界数据集非常昂贵，使用虚拟世界的数据更便宜，训练效果也更好，不过会增加数据集的偏差。</p>
<p>基于神经网络的感知系统有一个很大的问题，不确定性的反馈不足(insufficient feedback of uncertainty)。
网络不确定性可以由Monte Carlo dropout sampling (65)估计。
McAllister et al. (66)提出使用有原则的贝叶斯框架(a principled Bayesian framework)估计和传播整个系统管道中每个组件的不确定性，将使自动驾驶汽车能够适当地应对高不确定性。</p>
<h3 id="端到端规划end-to-end-planning"><a class="header" href="#端到端规划end-to-end-planning">端到端规划(End-to-End Planning)</a></h3>
<p>传统的自动驾驶架构中，功能被封装在模块之间清晰可见的接口中，也被称作中介感知(mediated perception)。</p>
<p>另一种架构是对感知模块的某些部分进行训练来包含规划模块的部分任务。</p>
<ul>
<li>Caltagirone et al. (68)，通过整合激光雷达点云、GPS-惯性测量单元（IMU）信息和谷歌导航信息来生成行驶路径。</li>
<li>语义分割网络可用于在相机图像空间(camera image space (69))中生成路径。</li>
</ul>
<p>更进一步，架构可以学习车道和道路跟踪的整个任务，而无需手动分解为道路或车道标记检测、语义抽象、路径规划和控制。</p>
<ul>
<li>ALVINN (Autonomous Land Vehicle in a Neural Network) (70)，训练神经网络从相机图像输出行驶的转向角，来让车辆保持在道路上行驶。</li>
<li>Chen et al. (67)将其称为behavior reflex approach。</li>
<li>NVIDIA (72)，训练了一个深度卷积神经网络，可以将前向摄像头的原始(raw)图像直接映射到转向命令，并能够处理具有挑战性的场景。</li>
<li>Bojarski et al. (73)，展示了神经网络能够学习类似车道标线、道路边界和其他车辆形状的特征(feature)。</li>
<li>Xu et al. (75)，使用大规模行驶视频数据集来训练了一个端到端的全卷积LSTM神经网络，可以预测离散行为(直行、停止、左转、右转)和连续行为(方向盘角度控制)。</li>
<li>SafeDAgger (76)，DAgger (77)。</li>
</ul>
<p>端到端运动规划也被运用于机器人学。</p>
<p>另一条研究路线是在模拟器中学习驾驶行为，可以在安全环境下观察失败的情况，适合强化学习的训练。</p>
<ul>
<li>Wolf et al. (81)，在模拟环境下使用Deep Q-Network来学习驾驶车辆。</li>
</ul>
<h2 id="4behavior-aware-motion-planning"><a class="header" href="#4behavior-aware-motion-planning">4.BEHAVIOR-AWARE MOTION PLANNING</a></h2>
<h2 id="5verification-and-synthesis"><a class="header" href="#5verification-and-synthesis">5.VERIFICATION AND SYNTHESIS</a></h2>
<h2 id="6fleet-management"><a class="header" href="#6fleet-management">6.FLEET MANAGEMENT</a></h2>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="a-review-of-mobile-robot-motion-planning-methods-from-classical-motion-planning-workflows-to-reinforcement-learning-based-architectures"><a class="header" href="#a-review-of-mobile-robot-motion-planning-methods-from-classical-motion-planning-workflows-to-reinforcement-learning-based-architectures">A Review of Mobile Robot Motion Planning Methods: from Classical Motion Planning Workflows to Reinforcement Learning-based Architectures</a></h1>
<p>主要分为三个部分：</p>
<ul>
<li>CLASSICAL MOTION PLANNING OF MRS</li>
<li>RL-based motion planning approaches
<ul>
<li>MAP-BASED CLASSICAL MOTION PLANNING ALGORITHMS WITH RL OPTIMIZATION</li>
<li>RL-BASED MAPLESS MOTION PLANNING METHODS</li>
<li>RL-BASED MULTI-ROBOT MOTION PLANNING</li>
</ul>
</li>
<li>DISCUSSION</li>
</ul>
<h2 id="classical-motion-planning-of-mrs"><a class="header" href="#classical-motion-planning-of-mrs">CLASSICAL MOTION PLANNING OF MRS</a></h2>
<p>首先需要获取map representation of the environment，包括occupancy grid map, point cloud map, Voronoi diagram map, Euclidean signed distance fields.</p>
<p>经典运动规划器的经典层次结构如下：</p>
<p><img src="autonomous-systems/assets/1.png" alt="Fig.1 An overall architecture diagram of the classical motion planning workflow" /></p>
<p>可以分成四个部分：discrete path searching, trajectory generation and optimization, trajectory tracking, and local planner.</p>
<h3 id="discrete-path-searching"><a class="header" href="#discrete-path-searching">discrete path searching</a></h3>
<p>传统全局DPS算法可以分为两类：the graph-searching-based algorithm (GSBA) and the sampling-based algorithm (SBA).</p>
<h4 id="gsba"><a class="header" href="#gsba">GSBA</a></h4>
<p>主要应用于低维空间上的路径规划问题.</p>
<p>dfs, bfs.</p>
<p>Dijkstra, A*.</p>
<p>Dynamic A* (D*), Lifelong planning A* (LPA*), D* Lite.</p>
<p>Jump point search (JPS), JPS+.</p>
<p>都没考虑运动动力学，State lattice methods被提出来解决这个问题.</p>
<h4 id="sba"><a class="header" href="#sba">SBA</a></h4>
<p>更适合高维空间.</p>
<p>Probabilistic road map (PRM), rapid-exploring random tree (RRT).</p>
<p>RRT*, RRT*-smart, RRT#.</p>
<p>fast match trees (FMT*).</p>
<p>kino-dynamic RRT*, informed RRT*, batch informed trees (BIT*).</p>
<p>Real-time RRT* (RT-RRT*), informationdriven RRT* (ID-RRT*).</p>
<h3 id="trajectory-generation-and-optimization"><a class="header" href="#trajectory-generation-and-optimization">trajectory generation and optimization</a></h3>
<p>大多数DPS算法只考虑工作空间的几何约束，在某些情况下，最终的最优或接近最优的分段轨迹对于实际的MR来说是不可执行的.</p>
<p>轨迹生成和优化（TGO）过程考虑了机器人的多重约束（例如，安全约束、运动动力学约束等），并将时间分配机制(time-allocation mechanism)纳入规划过程中，以赋予运动规划器更多的可执行能力。</p>
<h4 id="trajectory-generation"><a class="header" href="#trajectory-generation">trajectory generation</a></h4>
<p>interpolation-curve-based method: good continuity and differentiability，典型的包括Reeds and Sheep (RS) curves, clothoid curves, polynomial curves, Bezier curves.</p>
<h4 id="trajectory-optimization"><a class="header" href="#trajectory-optimization">trajectory optimization</a></h4>
<p>minimum snap algorithm.</p>
<p>EDF-based TGO method.</p>
<h3 id="trajectory-tracking"><a class="header" href="#trajectory-tracking">trajectory tracking</a></h3>
<p>使 MR 能够跟踪 TGO 流程规划的轨迹.</p>
<h3 id="local-planner"><a class="header" href="#local-planner">local planner</a></h3>
<p>MR需要具备局部重规划能力，以在跟踪全局轨迹的同时应对突发情况.</p>
<p>artificial potential field, reactive replanning method, fuzzy algorithm based method.</p>
<p>其中reactive replanning method 包括 directional approach, dynamic window approach (DWA).</p>
<h2 id="map-based-classical-motion-planning-algorithms-with-rl-optimization"><a class="header" href="#map-based-classical-motion-planning-algorithms-with-rl-optimization">MAP-BASED CLASSICAL MOTION PLANNING ALGORITHMS WITH RL OPTIMIZATION</a></h2>
<p>在上述传统架构中，规划架构的全局规划器和局部规划器是相互独立的，研究人员需要单独开发它们.此外，为了获得最终的可执行轨迹，研究人员必须解决具有多个约束的优化问题. 这个过程增加了规划方法的复杂性. 此外，经典的运动规划器包含各种子模块，每个子模块都需要繁琐的参数调整过程.</p>
<p><img src="autonomous-systems/assets/2.png" alt="Fig 2. A summary diagram of RL-based motion planning algorithms for the single mobile robot operation. We mainly review two types of research methods: map-based motion planning methods with RL optimization (the left branch, part a.), and the map-free end-to-end RL-based motion planning methods (the right branch, part b.)." /></p>
<h3 id="global-planners-combined-with-rl-improvements"><a class="header" href="#global-planners-combined-with-rl-improvements">Global Planners Combined with RL Improvements</a></h3>
<p>approximate value iteration (AVI) RL-based motion planning architecture</p>
<p>PRM-RL algorithm, RL-RRT, AutoRL-based PRM-RL.</p>
<h3 id="local-planners-combined-with-rl-improvements"><a class="header" href="#local-planners-combined-with-rl-improvements">Local Planners Combined with RL Improvements</a></h3>
<p>目的是让机器人在非结构化、动态和不确定的环境中具有更强的操作能力.</p>
<p>hybrid DWA-RL.</p>
<p>AHPF-RL.</p>
<p>Q-learning-based DWA.</p>
<p>soft actor-critic (SAC)-based local planner.</p>
<h2 id="rl-based-mapless-motion-planning-methods"><a class="header" href="#rl-based-mapless-motion-planning-methods">RL-BASED MAPLESS MOTION PLANNING METHODS</a></h2>
<p>在本节中，我们将审查的重点转移到基于端到端 RL 的运动规划方法，这些运动规划器是无地图的，实现了全局规划器和局部规划器的统一.</p>
<p>可以分为agent-level methods, sensor-level methods两个部分.</p>
<h3 id="agent-level-methods"><a class="header" href="#agent-level-methods">agent-level methods</a></h3>
<p>agent-level methods基于预设的状态估计过程，可以直接获取环境的上层状态信息，更容易训练，这使得机器人能够更快地获得最优规划策略. agent-level methods的观测维度较低，包含更多有用信息，其状态可以等效于原始传感器数据的特征提取之后的输出. 更重要的是，agent-level methods的模拟器的开发难度要小得多. 然而，此类方法依赖于完美感知的假设，或者需要考虑观察编码问题，或者需要额外的通信机制来共享状态信息，这些限制限制了agent-level methods的可扩展性和应用.</p>
<h3 id="sensor-level-methods"><a class="header" href="#sensor-level-methods">sensor-level methods</a></h3>
<p>sensor-level methods是端到端的，直接建立从原始传感器数据到规划决策的非线性映射.</p>
<p>根据主流研究趋势，以及常用的机器人感知方法，可以分为laser range finder (LRF) based methods 和 visual-based methods.</p>
<h4 id="laser-range-finder-based"><a class="header" href="#laser-range-finder-based">Laser Range Finder based</a></h4>
<p>intrinsic curiosity module</p>
<p>D. Pathak, P. Agrawal, A. A. Efros, and T. Darrell, “Curiosity-driven exploration by self-supervised prediction,” in International Conference on Machine Learning. PMLR, 2017, pp. 2778–2787.</p>
<p>H. Shi, L. Shi, M. Xu, and K.-S. Hwang, “End-to-end navigation strategy with deep reinforcement learning for mobile robots,” IEEE Transactions on Industrial Informatics, vol. 16, no. 4, pp. 2393–2402, 2019.</p>
<p>Y. Wang, H. He, and C. Sun, “Learning to navigate through complex dynamic environment with modular deep reinforcement learning,” IEEE Transactions on Games, vol. 10, no. 4, pp. 400–412, 2018.</p>
<p>EWC-DDPG.</p>
<p>上述大多数运动规划器只能部署在数值模拟空间中，sim-to-real problem.</p>
<p>asynchronous DDPG (ADDPG)-based motion planning algorithm.</p>
<p>assisted-DDPG (AsDDPG).</p>
<h4 id="vision-sensors"><a class="header" href="#vision-sensors">Vision sensors</a></h4>
<p>NavA3C algorithm.</p>
<p>DRL-based targetdriven visual navigation approach.</p>
<h2 id="rl-based-multi-robot-motion-planning"><a class="header" href="#rl-based-multi-robot-motion-planning">RL-BASED MULTI-ROBOT MOTION PLANNING</a></h2>
<h2 id="discussion"><a class="header" href="#discussion">DISCUSSION</a></h2>
<h3 id="challenges"><a class="header" href="#challenges">Challenges</a></h3>
<ul>
<li>Reality Gap</li>
<li>Sparse reward problem</li>
<li>Generalization</li>
<li>Low sample efficiency</li>
<li>Social etiquette</li>
<li>Lidar data pre-processing issues</li>
<li>Catastrophic forgetting problem</li>
</ul>
<h3 id="future-directions"><a class="header" href="#future-directions">Future Directions</a></h3>
<ul>
<li>Task-free RL-based general motion planner</li>
<li>Meta RL-based motion planning methods</li>
<li>Multi-modal fusion based RL motion planning methods</li>
<li>Multi-task objectives based RL motion planning methods</li>
<li>Human-Machine interaction mode based motion planning methods</li>
<li>RL-based motion planning of multiple heterogeneous MRs</li>
<li>Multi-MR flexible formation planning methods</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="rl"><a class="header" href="#rl">RL</a></h1>
<p>Reinforcement learning.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="asynchronous-methods-for-deep-reinforcement-learning"><a class="header" href="#asynchronous-methods-for-deep-reinforcement-learning">Asynchronous Methods for Deep Reinforcement Learning</a></h1>
<h2 id="reinforcement-learning-background"><a class="header" href="#reinforcement-learning-background">Reinforcement Learning Background</a></h2>
<p>Environment $E$, time step $t$, state $s_t$, action $a_t$, possible actions $A$, policy $\pi$, scalar reward $r_t$.</p>
<p>Return $R_t = \sum_{k=0}^\infty \gamma^k r_{t+k}, \gamma \in (0, 1]$.</p>
<p>Action value $Q^\pi(s, a) = \mathbb{E}[R_t | s_t = s, a]$ (expected return).</p>
<p>Optimal action value function $Q^*(s, a) = \max_\pi Q^\pi(s, a)$.</p>
<p>State value $V^\pi(s) = \mathbb{E}[R_t | s_t = s] = \sum_{a \in A} \pi(a | s) · Q^\pi(s, a)$.</p>
<h2 id="value-based-method-q-learning"><a class="header" href="#value-based-method-q-learning">value-based method (Q-learning)</a></h2>
<p>$Q(s, a ; \theta) \approx Q^*(s, a)$.</p>
<p>The $i$th loss function:</p>
<p>$$
L_i(\theta_i) = \mathbb{E}(r + \gamma \max_{a'} Q(s', a' ; \theta{i-1}) - Q(s, a ; \theta)) ^ 2
$$</p>
<p>where $s'$ is the state encountered after state $s$.</p>
<p>One-step Q-learning.</p>
<h2 id="policy-based-methods"><a class="header" href="#policy-based-methods">policy-based methods</a></h2>
<p>$\pi(a | s ; \theta)$.</p>
<p>Update the parameters $\theta$ by performing, typically approximate, gradient ascent on $E[R_t]$.</p>
<p>REINFORCE:</p>
<ul>
<li>Updates the policy parameters $\theta$ in the direction $\nabla_\theta \log \pi(a_t | s_t ; \theta) R_t$ which is an unbiased estimate of $\nabla_\theta \mathbb{E} [R_t]$.</li>
<li>Reduce the variance of this estimate while keeping it unbiased by subtracting a learned function of the state $b_t(s_t)$, known as a baseline (Williams, 1992), from the return. Resulting gradient: $\nabla_\theta \log \pi(a_t | s_t ; \theta) (R_t - b_t(s_t))$.</li>
</ul>
<p>Actor-critic:</p>
<ul>
<li>A learned estimate of the value function is commonly used as the baseline $b_t(s_t) \approx V^\pi(s_t)$ leading to a much lower variance estimate of the policy gradient.</li>
<li>The quantity $R_t − b_t$ used to scale the policy gradient can be seen as an estimate of the <em>advantage</em> of action at in state $s_t$, or $A(a_t, s_t) = Q(a_t, s_t)−V(s_t)$.</li>
</ul>
<h2 id="asynchronous-rl-framework"><a class="header" href="#asynchronous-rl-framework">Asynchronous RL Framework</a></h2>
<p>First, asynchronous actor-learners, multiple CPU threads on a single machine.</p>
<p>Second, make the observation that multiple actors-learners running in parallel are likely to be exploring different parts of the environment, use different exploration policies in each actor-learner to maximize this diversity.</p>
<p>Benefits:</p>
<ul>
<li>Stabilizing learning: By running different exploration policies in different threads, the overall changes being made to the parameters by multiple actor-learners applying online updates in parallel are likely to be less correlated in time than a single agent applying online updates.</li>
<li>Reduction in training time that is roughly linear in the number of parallel actor-learners.</li>
<li>Able to use on-policy reinforcement learning methods such as Sarsa and actor-critic to train neural networks in a stable way. </li>
</ul>
<h3 id="asynchronous-onestep-q-learning"><a class="header" href="#asynchronous-onestep-q-learning">Asynchronous onestep Q-learning</a></h3>
<p><img src="autonomous-systems/RL/assets/a3c-1.png" alt="Fig 1." /></p>
<h3 id="asynchronous-one-step-sarsa"><a class="header" href="#asynchronous-one-step-sarsa">Asynchronous one-step Sarsa</a></h3>
<p>Same as asynchronous one-step Q-learning except that it uses a different target value for $Q(s, a)$ : $r + \gamma Q(s', a' ; \theta^-)$.</p>
<h3 id="asynchronous-n-step-q-learning"><a class="header" href="#asynchronous-n-step-q-learning">Asynchronous n-step Q-learning</a></h3>
<p><img src="autonomous-systems/RL/assets/a3c-2.png" alt="Fig 2." /></p>
<h3 id="asynchronous-advantage-actor-critic-a3c"><a class="header" href="#asynchronous-advantage-actor-critic-a3c">Asynchronous advantage actor-critic (A3C)</a></h3>
<p>A3C maintains a policy $\pi(a_t|s_t; \theta)$ and an estimate of the value function $V(s_t; \theta_v)$.</p>
<p>Like the variant of n-step Q-learning, the variant of actor-critic also operates in the forward view and uses the same mix of n-step returns to update both the policy and the value-function.</p>
<p><img src="autonomous-systems/RL/assets/a3c-3.png" alt="Fig 3." /></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="curiosity-driven-exploration-by-self-supervised-prediction"><a class="header" href="#curiosity-driven-exploration-by-self-supervised-prediction">Curiosity-driven Exploration by Self-supervised Prediction</a></h1>
<p>In many real-world scenarios, rewards extrinsic to the agent are extremely sparse or missing altogether, and it is not possible to construct a shaped reward function.</p>
<p>In reinforcement learning, intrinsic motivation/rewards become critical whenever extrinsic rewards are sparse.</p>
<p>Two broad classes:</p>
<ul>
<li>encourage the agent to explore “novel” states</li>
<li>encourage the agent to perform actions that reduce the error/uncertainty in the agent’s ability to predict the consequence of its own actions</li>
</ul>
<p>The effectiveness of curiosity formulation in all three of these roles:</p>
<ul>
<li>solving tasks with sparse rewards</li>
<li>helps an agent explore its environment in the quest for new knowledge</li>
<li>learn skills that might be helpful in future scenarios</li>
</ul>
<h2 id="curiosity-driven-exploration"><a class="header" href="#curiosity-driven-exploration">Curiosity-Driven Exploration</a></h2>
<p>Intrinsic curiosity reward generated by the agent at time t: $r_t^i$, extrinsic reward: $r_t^e$, sum: $r_t = r_t^i + r_t^e$, with $r_t^e$ mostly zero.</p>
<p>Policy: $\pi(s_t ; \theta_P)$ by a deep neural network with parameters $\theta_P$.</p>
<p>Given the agent in state $s_t$, it executes the action $a_t \sim \pi(s_t ; \theta_P)$.</p>
<p>$\theta_P$ is optimized to maximize the expected sum of rewards:</p>
<p>$$
\max_{\theta_P} \mathbb{E}_{\pi(s_t ; \theta_P)} [\Sigma_t r_t]
$$</p>
<p>Asynchronous advantage actor critic policy gradient (A3C).</p>
<h3 id="prediction-error-as-curiosity-reward"><a class="header" href="#prediction-error-as-curiosity-reward">Prediction error as curiosity reward</a></h3>
<p>If not the raw observation space, then what is the right feature space for making predictions so that the prediction error provides a good measure of curiosity?</p>
<p>Divide all sources that can modify the agent’s observations into three cases:</p>
<ul>
<li>things that can be controlled by the agent;</li>
<li>things that the agent cannot control but that can affect the agent (e.g. a vehicle driven by another agent), and</li>
<li>things out of the agent’s control and not affecting the agent (e.g. moving leaves).</li>
</ul>
<p>A good feature space for curiosity should model (1) and (2) and be unaffected by (3).</p>
<h3 id="self-supervised-prediction-for-exploration"><a class="header" href="#self-supervised-prediction-for-exploration">Self-supervised prediction for exploration</a></h3>
<p>A general mechanism for learning feature representations such that the prediction error in the learned feature space provides a good intrinsic reward signal.</p>
<p>Train a deep neural network with two sub-modules:</p>
<ul>
<li>the first submodule encodes the raw state $(s_t)$ into a feature vector $\phi(s_t)$.</li>
<li>the second submodule takes as inputs the feature encoding $\phi(s_t), \phi(s_{t+1})$ of two consequent states and predicts the action $(a_t)$ taken by the agent to move from state $s_t$ to $s_{t+1}$.</li>
</ul>
<p>Training this neural network amounts to learning function $g$ defined as:</p>
<p>$$
\hat{a}<em>t = g(s_t, s</em>{t+1} ; \theta_I)
$$</p>
<p>The neural network parameters $\theta_I$ are trained to optimize:</p>
<p>$$
\min_{\theta_I} L_I(\hat{a}<em>t, a_t)
$$
The learned function $g$ is also known as the <strong>inverse dynamics model</strong> and the tuple $(s_t, a_t, s</em>{t+1})$ required to learn $g$ is obtained while the agent interacts with the environment using its current policy $\pi(s)$.</p>
<p>Train another neural network:</p>
<p>$$
\hat{\phi}(s_{t+1}) = f(\phi(s_t), a_t ; \theta_F)
$$</p>
<p>The neural network parameters $\theta_F$ are optimized by minimizing the loss function $L_F$:</p>
<p>$$
L_F(\phi(s_t), \hat{\phi}(s_{t+1})) = \frac{1}{2} \parallel \hat{\phi}(s_{t+1}) - \phi(s_{t+1}) \parallel _2^2
$$</p>
<p>The learned function $f$ is also known as the <strong>forward dynamics model</strong>.</p>
<p>The intrinsic reward signal is computed as:</p>
<p>$$
r_t^i = \frac{\eta}{2} \parallel \hat{\phi}(s_{t+1}) - \phi(s_{t+1}) \parallel _2^2
$$</p>
<p>Intrinsic Curiosity Module (ICM).</p>
<p>The overall optimization problem:</p>
<p>$$
\min_{\theta_P, \theta_I, \theta_F} [-\lambda \mathbb{E}_{\pi(s_t;\theta_P)}[\Sigma_t r_t] + (1-\beta) L_I + \beta L_F], 0 \leq \beta \leq 1, \lambda &gt; 0.
$$</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="end-to-end-navigation-strategy-with-deep-reinforcement-learning-for-mobile-robots"><a class="header" href="#end-to-end-navigation-strategy-with-deep-reinforcement-learning-for-mobile-robots">End-to-End Navigation Strategy With Deep Reinforcement Learning for Mobile Robots</a></h1>
<h2 id="problem-statement"><a class="header" href="#problem-statement">Problem Statement</a></h2>
<p>Navigation strategies for mobile robots in a map-less environment.</p>
<p>A motion planning model based on DRL. This end-to-end model transfers directly the inputs of the sensor observations and the relative position of the target to the commands of robot’s movement.</p>
<p>Uses <em>intrinsic curiosity</em> to allow agents to explore the environment more effectively and as an additional reward in an environment where the rewards are sparse. <em>Sparse laser ranging results</em> are also used as the highly abstracted inputs, so agent strategies that are learned by the simulation are effective in the real world.</p>
<h2 id="curiosity-driven-exploration-1"><a class="header" href="#curiosity-driven-exploration-1">Curiosity-Driven Exploration</a></h2>
<p>The original states $(s_t,s_{t+1})$ are encoded into the corresponding features $(\phi(s_t), \phi(s_{t+1}))$.</p>
<p>The inverse model is trained to predict at using state features $(\phi(s_t),\phi(s_{t+1}))$. </p>
<p>$a_t$ and $\phi(s_t)$ are passed to the forward model, which is used to predict the feature representation $\phi(s_{t+1})$ for the state $(s_{t+1})$ and compare it with the real feature $(\phi(s_t))$.</p>
<p>For the inverse model, the goal is to learn the function $g$ as follows:</p>
<p>$$
\hat{a}<em>t = g(s_t, s</em>{t+1} ; \theta_I)
$$</p>
<p>where $\hat{a}_t$ is the predicted value of the agent’s action $(a_t)$ and $\theta_I$ is the neural network parameter that is trained to be optimized as follows:</p>
<p>$$
\min_{\theta_I} L_I(\hat{a}_t, a_t)
$$</p>
<p>Since the action space is discrete, the output of $g$ is a soft-max distribution across all possible actions. </p>
<p>The loss function $L_I$ is set in the form of cross entropy as follows:</p>
<p>$$
L_I(\hat{a}<em>t, a_t) = \sum</em>{i=1}^n -P(a_{t_i}) \ln q(\hat{a}_{t_i})
$$</p>
<p>where $n$ is the size of the action space, $P(a_{t_i})$ is whether the agent chooses the $i$th action in the actual situation, and $q(\hat{a}_{t_i})$ is the probability of the agent choosing the $i$th action in the prediction result.</p>
<p>Another neural network is trained for the forward model:</p>
<p>$$
\hat{\phi}(s_{t+1}) = f(\phi(s_t), a_t, \theta_F)
$$</p>
<p>The training process is performed by minimizing the loss function LF as follows:</p>
<p>$$
L_F(\phi(s_t), \hat{\phi}(s_{t+1})) = \frac{1}{2} \parallel \hat{\phi}(s_{t+1}) - \phi(s_{t+1}) \parallel _2^2
$$</p>
<p>The intrinsic reward signal $r_t^i$ measured by the prediction error of the feature encoding is calculated as:</p>
<p>$$
r_t^i = \frac{\eta}{2} \parallel \hat{\phi}(s_{t+1}) - \phi(s_{t+1}) \parallel _2^2
$$</p>
<p>where $\eta &gt; 0$ is the scale factor used to adjust the intrinsic reward.</p>
<p><img src="autonomous-systems/RL/LRF/assets/navDRL-1.png" alt="Fig 1." /></p>
<h2 id="navigation-strategy-based-on-drl"><a class="header" href="#navigation-strategy-based-on-drl">Navigation Strategy Based on DRL</a></h2>
<p><img src="autonomous-systems/RL/LRF/assets/navDRL-2.png" alt="Fig 2." /></p>
<p>The first layer of LSTM accepts the previous rewards and observations. The aim is to establish an association between the original observations and rewards and transmit this to the next level of LSTM. The previous action is passed directly to the LSTM of the second layer.</p>
<p>Finally, connected to two separate output layers including softmax layer and linear layer, respectively, generating policy $\pi$ and value function $V$.</p>
<p>The reward function is divided into two components: the agent interacting with the environment obtains the extrinsic reward $r_t^e$ and the intrinsic reward $r_t^i$.</p>
<p>The policy $\pi(s_t ; \theta_p)$ is represented by a deep neural network with the parameter $\theta_p$.</p>
<p>Sum of the intrinsic reward: $r_t = r_t^e + r_t^i$.</p>
<p>The problem that needs to be optimized overall:</p>
<p>$$
\min_{\theta_p, \theta_I, \theta_F} \Big [-\lambda \mathbb{E}_{\pi(s_t ; \theta_p)}\big [ \sum_t r_t \big ] + (1-\beta) L_I + \beta L_F \Big ]
$$</p>
<p>where $\lambda &gt; 0$ is used to adjust the weight of the policy gradient loss for the curiosity reward, and $0 \leq \beta \leq 1$ is used to adjust the weight between the forward model loss and the inverse model loss.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
